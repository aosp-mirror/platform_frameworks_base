/*
 * Copyright (C) 2019, The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "atoms_info_writer.h"

#include <map>
#include <set>
#include <vector>

#include "utils.h"

namespace android {
namespace stats_log_api_gen {

static void write_atoms_info_header_body(FILE* out) {
    fprintf(out, "struct AtomsInfo {\n");
    fprintf(out, "  const static std::set<int> kAtomsWithAttributionChain;\n");
    fprintf(out, "  const static std::set<int> kWhitelistedAtoms;\n");
    fprintf(out, "};\n");
}

static void write_atoms_info_cpp_body(FILE* out, const Atoms& atoms) {

    fprintf(out, "const std::set<int> AtomsInfo::kAtomsWithAttributionChain = {\n");
    for (AtomDeclSet::const_iterator atomIt = atoms.decls.begin(); atomIt != atoms.decls.end();
         atomIt++) {
        for (vector<AtomField>::const_iterator field = (*atomIt)->fields.begin();
             field != (*atomIt)->fields.end(); field++) {
            if (field->javaType == JAVA_TYPE_ATTRIBUTION_CHAIN) {
                const string constant = make_constant_name((*atomIt)->name);
                fprintf(out, "    %d, // %s\n", (*atomIt)->code, constant.c_str());
                break;
            }
        }
    }

    fprintf(out, "};\n");
    fprintf(out, "\n");

    fprintf(out, "const std::set<int> AtomsInfo::kWhitelistedAtoms = {\n");
    for (AtomDeclSet::const_iterator atomIt = atoms.decls.begin(); atomIt != atoms.decls.end();
         atomIt++) {
        if ((*atomIt)->whitelisted) {
            const string constant = make_constant_name((*atomIt)->name);
            fprintf(out, "    %d, // %s\n", (*atomIt)->code, constant.c_str());
        }
    }

    fprintf(out, "};\n");
    fprintf(out, "\n");

}

int write_atoms_info_header(FILE* out, const string& namespaceStr) {
    // Print prelude
    fprintf(out, "// This file is autogenerated\n");
    fprintf(out, "\n");
    fprintf(out, "#pragma once\n");
    fprintf(out, "\n");
    fprintf(out, "#include <vector>\n");
    fprintf(out, "#include <map>\n");
    fprintf(out, "#include <set>\n");
    fprintf(out, "\n");

    write_namespace(out, namespaceStr);

    write_atoms_info_header_body(out);

    fprintf(out, "\n");
    write_closing_namespace(out, namespaceStr);

    return 0;
}

int write_atoms_info_cpp(FILE* out, const Atoms& atoms, const string& namespaceStr,
                         const string& importHeader) {
    // Print prelude
    fprintf(out, "// This file is autogenerated\n");
    fprintf(out, "\n");
    fprintf(out, "#include <%s>\n", importHeader.c_str());
    fprintf(out, "\n");

    write_namespace(out, namespaceStr);

    write_atoms_info_cpp_body(out, atoms);

    // Print footer
    fprintf(out, "\n");
    write_closing_namespace(out, namespaceStr);

    return 0;
}

}  // namespace stats_log_api_gen
}  // namespace android
